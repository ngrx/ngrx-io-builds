{
  "id": "guide/signals/signal-store/testing",
  "title": "Testing",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"testing\">Testing<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#testing\"><i class=\"material-icons\">link</i></a></h1>\n<p>A SignalStore is a straightforward Angular service, and the same testing techniques applied to other services also apply to SignalStore. This guide provides examples for common testing scenarios.</p>\n<p>One of the challenges in testing is managing asynchronous tasks and mocking dependencies. Although the examples use Jest, the same principles are applicable to other testing frameworks.</p>\n<p>There are two primary scenarios for testing:</p>\n<ol>\n<li>Testing the SignalStore itself.</li>\n<li>Testing a component or service that utilizes the SignalStore.</li>\n</ol>\n<p>In the first scenario, the dependencies of the SignalStore should be mocked, while in the second scenario, the SignalStore itself needs to be mocked.</p>\n<hr>\n<p>When testing the SignalStore, interaction should occur through its public API, as any component or service would.</p>\n<p>A key concern in testing is maintainability. The more tests are coupled to internal implementations, the more frequently they are likely to break. Public APIs are generally more stable and less prone to change.</p>\n<p>For example, when testing the store in a loading state, avoid directly setting the loading property. Instead, trigger a loading method and assert against an exposed computed property or slice. This approach reduces dependency on internal implementations, such as properties set during the loading state.</p>\n<p>From this perspective, private properties or methods of the SignalStore should not be accessed. Additionally, avoid running <code><a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a></code> if the state is protected.</p>\n<hr>\n<p>The SignalStore is a function that returns a class, allowing tests to instantiate the class and test it without using <code>TestBed</code>.</p>\n<p>However, in practice, <code>TestBed</code> is typically used due to its numerous advantages, such as the ability to mock dependencies and trigger the execution of effects.</p>\n<p>Additionally, key features of the SignalStore do not function properly if they do not run in an injection context. Examples include <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code>, the use of <code>inject</code> within <code><a href=\"api/signals/withMethods\" class=\"code-anchor\">withMethods</a>()</code>, and <code><a href=\"api/signals/withHooks\" class=\"code-anchor\">withHooks</a>()</code>.</p>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> Using the <code>TestBed</code> is also the recommendation of the <a href=\"https://github.com/angular/angular/issues/54438#issuecomment-1971813177\">Angular team</a>.</p>\n</div>\n<h2 id=\"testing-the-signalstore\">Testing the SignalStore<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#testing-the-signalstore\"><i class=\"material-icons\">link</i></a></h2>\n<p>The following example demonstrates the testing of a SignalStore:</p>\n<h3 id=\"globally-provided\">Globally provided<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#globally-provided\"><i class=\"material-icons\">link</i></a></h3>\n<code-example header=\"movies.store.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>, <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a> } from '@ngrx/signals';\n\n<a href=\"api/signals/type\" class=\"code-anchor\">type</a> Movie = {\n  <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: number;\n  name: string;\n};\n\n<a href=\"api/signals/type\" class=\"code-anchor\">type</a> <a href=\"api/store/State\" class=\"code-anchor\">State</a> = { movies: Movie[] };\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const MoviesStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>(\n  { providedIn: 'root' },\n  <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a>&#x3C;<a href=\"api/store/State\" class=\"code-anchor\">State</a>>({\n    movies: [\n      { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'A New Hope' },\n      { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Into Darkness' },\n      { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 3, name: 'The Lord of the Rings' },\n    ],\n  })\n);\n\n</code-example>\n<p>The <code>TestBed</code> instantiates the <code>MoviesStore</code>, enabling immediate testing.</p>\n<code-example header=\"movies.store.spec.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { MoviesStore } from './movies-store';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { TestBed } from '@angular/core/testing';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.movies()).toHaveLength(3);\n  });\n});\n\n</code-example>\n<h3 id=\"locally-provided\">Locally Provided<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#locally-provided\"><i class=\"material-icons\">link</i></a></h3>\n<p>This is possible due to the <code>MoviesStore</code> being provided globally. For locally provided stores, some adjustments to the test are required.</p>\n<code-example header=\"movies.store.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const MoviesStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>(\n  <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a>({\n    movies: [\n      // ... entries\n    ],\n  })\n);\n\n</code-example>\n<p>The required addition is that the internal <code>TestingModule</code> must provide the <code>MoviesStore</code>.</p>\n<code-example header=\"movies.store.spec.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { MoviesStore } from './movies.store';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    TestBed.configureTestingModule({\n      providers: [MoviesStore],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.movies()).toHaveLength(3);\n  });\n});\n\n</code-example>\n<h3 id=\"withcomputed\"><code><a href=\"api/signals/withComputed\" class=\"code-anchor\">withComputed</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#withcomputed\"><i class=\"material-icons\">link</i></a></h3>\n<p>Testing derived values of <code><a href=\"api/signals/withComputed\" class=\"code-anchor\">withComputed</a></code> is also straightforward.</p>\n<code-example header=\"movies.store.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const MoviesStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>(\n  <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a>({\n    movies: [\n      // ... entries\n    ],\n  }),\n  <a href=\"api/signals/withComputed\" class=\"code-anchor\">withComputed</a>((state) => ({\n    moviesCount: computed(() => state.movies().length),\n  }))\n);\n\n</code-example>\n<code-example header=\"movies.store.spec.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { MoviesStore } from './movies.store';\n\ndescribe('MoviesStore', () => {\n  it('should verify that three movies are available', () => {\n    const store = TestBed.inject(MoviesStore);\n\n    expect(store.moviesCount()).toBe(3);\n  });\n});\n\n</code-example>\n<h3 id=\"withmethods-dependency-injection-and-asynchronous-tasks\"><code><a href=\"api/signals/withMethods\" class=\"code-anchor\">withMethods</a></code>, Dependency Injection, and Asynchronous Tasks<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#withmethods-dependency-injection-and-asynchronous-tasks\"><i class=\"material-icons\">link</i></a></h3>\n<p>A loading method asynchronously retrieves movies by studio in this scenario.</p>\n<code-example header=\"movies.store.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>, <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a> } from '@ngrx/signals';\n\n<a href=\"api/signals/type\" class=\"code-anchor\">type</a> <a href=\"api/store/State\" class=\"code-anchor\">State</a> = { studio: string; movies: Movie[]; <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: boolean };\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const MoviesStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>(\n  <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a>&#x3C;<a href=\"api/store/State\" class=\"code-anchor\">State</a>>({\n    studio: '',\n    movies: [],\n    <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: false,\n  }),\n  <a href=\"api/signals/withMethods\" class=\"code-anchor\">withMethods</a>((store) => {\n    const moviesService = store.inject(MoviesService);\n\n    return {\n      async load(studio: string) {\n        this.patchState({ <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: true });\n        const movies = await moviesService.loadMovies(studio);\n        this.patchState(store, { studio, movies, <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: false });\n      },\n    };\n  })\n);\n\n</code-example>\n<p>The <code>MoviesService</code> is mocked in the test, with the implementation returning the result as a <code>Promise</code>.</p>\n<code-example header=\"movies.store.spec.ts\">\n\ndescribe('MoviesStore', () => {\n  it('should load movies of Warner Bros', fakeAsync(() => {\n    const moviesService = {\n      load: () =>\n        Promise.resolve([\n          { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' },\n          { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'The Dark Knight' },\n        ]),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n    store.load('Warner Bros');\n    expect(store.loading()).toBe(true);\n    \n    tick();\n\n    expect(store.moviesCount()).toBe(2);\n    expect(store.loading()).toBe(false);\n  }));\n});\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p><strong>Note:</strong> Manually mocking dependencies is not required. Libraries such as ng-mocks, @testing-library/angular, and [jest|jasmine]-auto-spies can be used for this purpose.</p>\n</div>\n<h3 id=\"rxmethod\"><code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#rxmethod\"><i class=\"material-icons\">link</i></a></h3>\n<p>The <code>load</code> method is created using <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code> to accommodate a component that provides an input field for the studio and initiates loading as soon as a user types in a name.</p>\n<p>In this scenario, the <code>MovieService</code> returns an <code>Observable&#x3C;Movie[]></code> instead of a <code>Promise&#x3C;Movie[]></code>.</p>\n<code-example header=\"movies.store.ts\">\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const MoviesStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>(\n  // ... code omitted\n  <a href=\"api/signals/withMethods\" class=\"code-anchor\">withMethods</a>((store, moviesService = inject(MoviesService)) => ({\n    load: <a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a>&#x3C;string>(\n      pipe(\n        tap(() => <a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a>(store, { <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: true })),\n        switchMap((studio) =>\n          moviesService.load(studio).pipe(\n            <a href=\"api/operators/tapResponse\" class=\"code-anchor\">tapResponse</a>({\n              next: (movies) =>\n                <a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a>(store, { movies, <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: false }),\n              error: console.error,\n            })\n          )\n        )\n      )\n    ),\n  }))\n);\n\n</code-example>\n<p>Since <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code> accepts a string as a parameter, the previous test remains valid.</p>\n<p>An additional focus in testing is ensuring proper handling of race conditions, which is why <code>switchMap</code> is used.</p>\n<p>The parameter's type can also be <code>Signal&#x3C;number></code> or <code>Observable&#x3C;number></code>, in addition to <code>number</code>.</p>\n<h4 id=\"with-observables\">With Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#with-observables\"><i class=\"material-icons\">link</i></a></h4>\n<p>The goal is to test whether the <code>load</code> method properly handles the scenario where a new studio name is entered before or after the previous request has completed.</p>\n<code-example header=\"movies.store.spec.ts\">\n\ndescribe('MoviesStore', () => {\n  // ... beforeEach and afterEach omitted\n\n  const setup = () => {\n    const moviesService = {\n      load: jest.fn((studio: string) =>\n        of([\n          studio === 'Warner Bros'\n            ? { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' }\n            : { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }\n        ]).pipe(delay(100))\n      ),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    return TestBed.inject(MoviesStore);\n  };\n\n  it('should load two times', fakeAsync(() => {\n    const store = setup();\n\n    const studio$ = new Subject&#x3C;string>();\n    store.load(studio$);\n    studio$.next('Warner Bros');\n\n    tick(100);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' }]);\n\n    studio$.next('Universal');\n    tick(100);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }]);\n  }));\n\n  it('should cancel a running request when a new one is made', fakeAsync(() => {\n    const store = setup();\n\n    const studio$ = new Subject&#x3C;string>();\n    store.load(studio$);\n    studio$.next('Warner Bros');\n\n    tick(50);\n    studio$.next('Universal');\n\n    tick(50);\n    expect(store.movies()).toEqual([]);\n    expect(store.loading()).toBe(true);\n\n    tick(50);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }]);\n    expect(store.loading()).toBe(false);\n  }));\n});\n\n</code-example>\n<p>By utilizing the testing framework's function to manage time, both scenarios can be verified.</p>\n<p>The test also employs a setup function to prevent code duplication, a common pattern in testing and an alternative to the <code>beforeEach</code> function. In this case, each test can choose whether to use the setup function or not.</p>\n<h4 id=\"with-signals\">With Signals<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#with-signals\"><i class=\"material-icons\">link</i></a></h4>\n<p>Testing both scenarios with a <code>Signal</code> type as input is similar to testing with Observables.</p>\n<p>This similarity arises primarily due to the asynchronous tasks involved.</p>\n<code-example header=\"movies.store.spec.ts\">\n\ndescribe('MoviesStore', () => {\n  // ... setup omitted\n\n  it('should test two sequential loads with a Signal', fakeAsync(() => {\n    const store = setup();\n    const studio = signal('Warner Bros');\n    store.load(studio);\n\n    tick(100);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' }]);\n\n    studio.set('Universal');\n    tick(100);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }]);\n  }));\n\n  it('should cancel a running request when a new one is made via a Signal', fakeAsync(() => {\n    const store = setup();\n    const studio = signal('Warner Bros');\n\n    <a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a>(() => {\n      console.log(studio());\n    });\n    store.load(studio);\n\n    tick(50);\n\n    studio.set('Universal');\n    tick(50);\n    expect(store.movies()).toEqual([]);\n    expect(store.loading()).toBe(true);\n\n    tick(50);\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }]);\n    expect(store.loading()).toBe(false);\n  }));\n});\n\n</code-example>\n<p>It is important to account for the glitch-free effect when using Signals. The <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code> relies on <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code>, which may need to be triggered manually through <code>TestBed.flushEffects()</code>.</p>\n<p>If the mocked <code>MovieService</code> operates synchronously, the following test fails unless <code>TestBed.flushEffects()</code> is called.</p>\n<code-example header=\"movies.store.spec.ts\">\n\ndescribe('MoviesStore', () => {\n  // ... beforeEach, and afterEach omitted\n\n  it('should depend <a href=\"api/store/on\" class=\"code-anchor\">on</a> flushEffects because of synchronous execution', () => {\n    const moviesService = {\n      load: jest.fn((studio: string) =>\n        of([\n          studio === 'Warner Bros'\n            ? { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' }\n            : { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }\n        ])\n      ),\n    };\n\n    TestBed.configureTestingModule({\n      providers: [\n        {\n          provide: MoviesService,\n          useValue: moviesService,\n        },\n      ],\n    });\n\n    const store = TestBed.inject(MoviesStore);\n    const studio = signal('Warner Bros');\n    store.load(studio);\n    TestBed.flushEffects(); // required\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' }]);\n\n    studio.set('Universal');\n    TestBed.flushEffects(); // required\n    expect(store.movies()).toEqual([{ <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'Jurassic Park' }]);\n  });\n});\n\n</code-example>\n<h2 id=\"mocking-the-signalstore\">Mocking the SignalStore<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#mocking-the-signalstore\"><i class=\"material-icons\">link</i></a></h2>\n<p>What applies to testing the SignalStore also applies to mocking it. The SignalStore functions like any other service, meaning it can be mocked using the same tools and techniques applied to other services.</p>\n<p>The <code>MovieComponent</code> utilizes the <code>MoviesStore</code> to display movies:</p>\n<code-example header=\"movies.component.ts\">\n\n@Component({\n  <a href=\"api/store/testing/MockSelector#selector\" class=\"code-anchor\">selector</a>: 'app-movies',\n  template: `\n    &#x3C;input\n      <a href=\"api/signals/type\" class=\"code-anchor\">type</a>=\"text\"\n      [(ngModel)]=\"studio\"\n      [disabled]=\"store.loading()\"\n      placeholder=\"Name of Studio\"\n    />\n\n    &#x3C;ul>\n      @for (movie of store.movies(); track movie.id) {\n      &#x3C;p>{{ movie.id }}: {{ movie.name }}&#x3C;/p>\n      }\n    &#x3C;/ul>\n  `,\n  standalone: true,\n  imports: [FormsModule],\n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class MoviesComponent {\n  protected studio = signal('');\n  protected readonly store = inject(MoviesStore);\n\n  constructor() {\n    this.store.load(this.studio);\n  }\n}\n\n</code-example>\n<h3 id=\"native-mocking\">Native Mocking<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#native-mocking\"><i class=\"material-icons\">link</i></a></h3>\n<code-example header=\"movies.component.spec.ts\">\n\nit('should show movies (native Jest)', () => {\n  const load = jest.fn&#x3C;void, [Signal&#x3C;string>]>();\n\n  const moviesStore = {\n    movies: signal(new Array&#x3C;Movie>()),\n    <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: signal(false),\n    load,\n  };\n\n  TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [\n      {\n        provide: MoviesStore,\n        useValue: moviesStore,\n      },\n    ],\n  });\n\n  const fixture = TestBed.createComponent(MoviesComponent);\n  fixture.autoDetectChanges(true);\n\n  const studio = load.mock.calls[0][0];\n  const input: HTMLInputElement = fixture.debugElement.query(By.css('input')).nativeElement;\n\n  expect(studio()).toBe('');\n\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n  expect(studio()).toBe('Warner Bros');\n\n  moviesStore.movies.set([\n    { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' },\n    { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'The Dark Knight' },\n  ]);\n  fixture.detectChanges();\n\n  const movieNames = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movieNames).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n});\n\n</code-example>\n<p>The test mocks only the properties and methods used by the component in the specific test. Even if a SignalStore contains additional methods, it is not necessary to mock all of them.</p>\n<h3 id=\"partial-mocking-via-spies\">\"Partial Mocking\" via Spies<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#partial-mocking-via-spies\"><i class=\"material-icons\">link</i></a></h3>\n<p>Partial mocking can be used to mock only the <code>load</code> method. This approach allows computed properties to function correctly without requiring them to be mocked.</p>\n<code-example header=\"movies.component.spec.ts\">\n\nit('should show movies (spy)', () => {\n  TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [\n      {\n        provide: MoviesService,\n        useValue: {},\n      },\n    ],\n  });\n\n  const moviesStore = TestBed.inject(MoviesStore);\n  const loadSpy = jest.spyOn(moviesStore, 'load');\n  const fixture = TestBed.createComponent(MoviesComponent);\n\n  fixture.autoDetectChanges(true);\n\n  const studio = loadSpy.mock.calls[0][0];\n  if (studio instanceof Observable || typeof studio === 'string') {\n    throw new Error('Expected signal');\n  }\n\n  const input: HTMLInputElement = fixture.debugElement.query(By.css('input')).nativeElement;\n\n  expect(studio()).toBe('');\n\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n  expect(studio()).toBe('Warner Bros');\n\n  <a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a>(moviesStore, {\n    movies: [\n      { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter' },\n      { <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'The Dark Knight' },\n    ],\n  });\n\n  fixture.detectChanges();\n\n  const movies = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movies).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n});\n\n</code-example>\n<p>This version requires the <code>MoviesStore</code> state to be unprotected.</p>\n<h2 id=\"integration-tests\">Integration Tests<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#integration-tests\"><i class=\"material-icons\">link</i></a></h2>\n<p>Services attached to a component are often simple, and writing unit tests for them may not always be necessary, particularly when considering the returned value and maintenance costs. In such cases, it is more effective to test the services together with the component as a whole. This type of testing is commonly referred to as integration testing.</p>\n<p>The same applies to the SignalStore. If the SignalStore, such as the <code>MoviesStore</code>, is relatively simple, a single test can cover both the <code>MoviesComponent</code> and the <code>MoviesStore</code>. However, the <code>HttpClient</code> must still be replaced with a test double.</p>\n<code-example header=\"movies.spec.ts\">\n\nit('should show movies with MoviesStore', async () => {\n  const fixture = TestBed.configureTestingModule({\n    imports: [MoviesComponent],\n    providers: [provideHttpClient(), provideHttpClientTesting()],\n  }).createComponent(MoviesComponent);\n\n  const ctrl = TestBed.inject(HttpTestingController);\n\n  fixture.autoDetectChanges(true);\n\n  const input: HTMLInputElement = fixture.debugElement.query(\n    By.css('input')\n  ).nativeElement;\n  input.value = 'Warner Bros';\n  input.dispatchEvent(new Event('input'));\n\n\n  ctrl.expectOne('https://movies.com/studios?query=Warner%20Bros').flush(\n    [\n      {<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 1, name: 'Harry Potter'},\n      {<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: 2, name: 'The Dark Knight'},\n    ]\n  )\n  await fixture.whenStable()\n\n  const movies = fixture.debugElement.queryAll(By.css('p')).map((el) =>\n    el.nativeElement.textContent\n  );\n  expect(movies).toEqual(['1: Harry Potter', '2: The Dark Knight']);\n  ctrl.verify();\n});\n\n</code-example>\n<p>This test assumes that the <code>MoviesService</code> sends a request.</p>\n<h2 id=\"testing-custom-extensions\">Testing Custom Extensions<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-store/testing#testing-custom-extensions\"><i class=\"material-icons\">link</i></a></h2>\n<p>An extension is responsible for playing a movie and tracking the duration of viewership. The extension provides <code>play</code> and <code>stop</code> methods, along with a Signal containing the movie's ID and the time spent watching it.</p>\n<code-example header=\"with-play-tracking.ts\">\n\n<a href=\"api/signals/type\" class=\"code-anchor\">type</a> PlayTrackingState = {\n  _currentId: number;\n  _status: 'playing' | 'stopped';\n  _startedAt: Date | undefined;\n  trackedData: Record&#x3C;number, number>;\n};\n\nconst initialState: PlayTrackingState = {\n  _currentId: 0,\n  _status: 'stopped',\n  _startedAt: undefined,\n  trackedData: {},\n};\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> const withPlayTracking = () =>\n  <a href=\"api/signals/signalStoreFeature-0\" class=\"code-anchor\">signalStoreFeature</a>(\n    <a href=\"api/signals/withState\" class=\"code-anchor\">withState</a>(initialState),\n    <a href=\"api/signals/withMethods\" class=\"code-anchor\">withMethods</a>((store) => {\n      const stop = () => {\n        const startedAt = store._startedAt();\n        if (!startedAt || store._status() === 'stopped') {\n          return;\n        }\n\n        const timeSpent = new Date().getTime() - startedAt.getTime();\n        const alreadySpent = store.trackedData()[store._currentId()] ?? 0;\n        <a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a>(store, (state) => ({\n          _currentId: 0,\n          _status: 'stopped' as const,\n          trackedData: { ...state.trackedData, [state._currentId]: alreadySpent + timeSpent },\n        }));\n      };\n\n      return {\n        play(<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>: number) {\n          stop();\n          <a href=\"api/signals/patchState\" class=\"code-anchor\">patchState</a>(store, {\n            _currentId: <a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>,\n            _status: 'playing',\n            _startedAt: new Date(),\n          });\n        },\n        stop,\n      };\n    })\n  );\n\n</code-example>\n<p>There are two options for testing this extension: in combination with the <code>MoviesStore</code> or in isolation.</p>\n<p>When tested with the <code>MoviesStore</code>, the same approach as in previous examples is followed.</p>\n<p>To test the extension in isolation, an artificial \"Wrapper\" SignalStore is created. The test process remains straightforward.</p>\n<code-example header=\"with-play-tracking.spec.ts\">\n\ndescribe('withTrackedPlay', () => {\n  const TrackedPlayStore = <a href=\"api/signals/signalStore\" class=\"code-anchor\">signalStore</a>({ providedIn: 'root' }, withPlayTracking());\n\n  it('should track movies', fakeAsync(() => {\n    const store = TestBed.inject(TrackedPlayStore);\n\n    store.play(1);\n    tick(1000);\n\n    store.stop();\n    store.play(2);\n    tick(1000);\n\n    store.play(3);\n    tick(1000);\n\n    store.play(1);\n    tick(1000);\n    store.stop();\n\n    expect(store.trackedData()).toEqual({ 1: 2000, 2: 1000, 3: 1000 });\n  }))\n});\n\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/data/EntityCollection#loading\n - api/data/UpdateResponseData#id\n - api/effects/EffectNotification#effect\n - api/operators/tapResponse\n - api/signals/patchState\n - api/signals/rxjs-interop/rxMethod\n - api/signals/signalStore\n - api/signals/signalStoreFeature-0\n - api/signals/type\n - api/signals/withComputed\n - api/signals/withHooks\n - api/signals/withMethods\n - api/signals/withState\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store-devtools/DevToolsFeatureOptions#import\n - api/store/State\n - api/store/on\n - api/store/testing/MockSelector#selector\n - guide/signals/signal-store/testing#globally-provided\n - guide/signals/signal-store/testing#integration-tests\n - guide/signals/signal-store/testing#locally-provided\n - guide/signals/signal-store/testing#mocking-the-signalstore\n - guide/signals/signal-store/testing#native-mocking\n - guide/signals/signal-store/testing#partial-mocking-via-spies\n - guide/signals/signal-store/testing#rxmethod\n - guide/signals/signal-store/testing#testing\n - guide/signals/signal-store/testing#testing-custom-extensions\n - guide/signals/signal-store/testing#testing-the-signalstore\n - guide/signals/signal-store/testing#with-observables\n - guide/signals/signal-store/testing#with-signals\n - guide/signals/signal-store/testing#withcomputed\n - guide/signals/signal-store/testing#withmethods-dependency-injection-and-asynchronous-tasks\n - https://github.com/angular/angular/issues/54438#issuecomment-1971813177\n - https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/signals/signal-store/testing.md?message=docs%3A%20describe%20your%20change...\n-->"
}