{
  "id": "guide/signals/signal-method",
  "title": "SignalMethod",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/signals/signal-method.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"signalmethod\">SignalMethod<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#signalmethod\"><i class=\"material-icons\">link</i></a></h1>\n<p><code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> is a standalone factory function used for managing side effects with Angular signals. It accepts a callback and returns a processor function that can handle either a static value or a signal. The input type can be specified using a generic type argument:</p>\n<code-example language=\"ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { Component } from '@angular/core';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a> } from '@ngrx/signals';\n\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent {\n  // ðŸ‘‡ This <a href=\"api/data/RequestData#method\" class=\"code-anchor\">method</a> will have an input argument\n  // of <a href=\"api/signals/type\" class=\"code-anchor\">type</a> `number | Signal&#x3C;number>`.\n  readonly logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n}\n</code-example>\n<p><code>logDoubledNumber</code> can be called with a static value of type <code>number</code>, or a Signal of type <code>number</code>:</p>\n<code-example language=\"ts\">\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent {\n  readonly logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n\n  constructor() {\n    this.logDoubledNumber(1);\n    // console output: 2\n\n    const num = signal(2);\n    this.logDoubledNumber(num);\n    // console output: 4\n    \n    setTimeout(() => num.set(3), 3_000);\n    // console output after 3 seconds: 6\n  }\n}\n</code-example>\n<h2 id=\"automatic-cleanup\">Automatic Cleanup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#automatic-cleanup\"><i class=\"material-icons\">link</i></a></h2>\n<p><code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> uses an <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code> internally to track the Signal changes.\nBy default, the <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code> runs in the injection context of the caller. In the example above, that is <code>NumbersComponent</code>. That means, that the <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code> is automatically cleaned up when the component is destroyed.</p>\n<p>If the call happens outside an injection context, then the injector of the <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> is used. This would be the case, if <code>logDoubledNumber</code> runs in <code>ngOnInit</code>:</p>\n<code-example language=\"ts\">\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent implements OnInit {\n  readonly logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n\n  ngOnInit(): void {\n    const <a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a> = signal(2);\n    // ðŸ‘‡ Uses the injection context of the `NumbersComponent`.\n    this.logDoubledNumber(<a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a>);\n  }\n}\n</code-example>\n<p>Even though <code>logDoubledNumber</code> is called outside an injection context, automatic cleanup occurs when <code>NumbersComponent</code> is destroyed, since <code>logDoubledNumber</code> was created within the component's injection context.</p>\n<p>However, when creating a <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> in an ancestor injection context, the cleanup behavior is different:</p>\n<code-example language=\"ts\">\n@Injectable({ providedIn: 'root' })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersService {\n  readonly logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>((num) => {\n    const double = num * 2;\n    console.log(double);\n  });\n}\n\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent implements OnInit {\n  readonly numbersService = inject(NumbersService);\n\n  ngOnInit(): void {\n    const <a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a> = signal(2);\n    // ðŸ‘‡ Uses the injection context of the `NumbersService`, which is root.\n    this.numbersService.logDoubledNumber(<a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a>);\n  }\n}\n</code-example>\n<p>Here, the <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code> outlives the component, which would produce a memory leak.</p>\n<h2 id=\"manual-cleanup\">Manual Cleanup<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#manual-cleanup\"><i class=\"material-icons\">link</i></a></h2>\n<p>When a <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> is created in an ancestor injection context, it's necessary to explicitly provide the caller injector to ensure proper cleanup:</p>\n<code-example language=\"ts\">\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent implements OnInit {\n  readonly numbersService = inject(NumbersService);\n  readonly injector = inject(Injector);\n\n  ngOnInit(): void {\n    const <a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a> = signal(1);\n    // ðŸ‘‡ Providing the `NumbersComponent` injector\n    // to ensure cleanup <a href=\"api/store/on\" class=\"code-anchor\">on</a> component destroy.\n    this.numbersService.logDoubledNumber(<a href=\"api/store/testing/MockSelector#value\" class=\"code-anchor\">value</a>, {\n      injector: this.injector,\n    });\n  \n    // ðŸ‘‡ No need to provide an injector for static values.\n    this.numbersService.logDoubledNumber(2);\n  }\n}\n</code-example>\n<h2 id=\"initialization-outside-of-injection-context\">Initialization Outside of Injection Context<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#initialization-outside-of-injection-context\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> must be initialized within an injection context. To initialize it outside an injection context, it's necessary to provide an injector as the second argument:</p>\n<code-example language=\"ts\">\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent implements OnInit {\n  readonly injector = inject(Injector);\n\n  ngOnInit() {\n    const logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>(\n      (num) => console.log(num * 2),\n      { injector: this.injector },\n    );\n  }\n}\n</code-example>\n<h2 id=\"advantages-over-effect\">Advantages over Effect<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#advantages-over-effect\"><i class=\"material-icons\">link</i></a></h2>\n<p>At first sight, <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code>, might be the same as <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code>:</p>\n<code-example language=\"ts\">\n@Component({ /* ... */ })\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class NumbersComponent {\n  readonly num = signal(2);\n  readonly logDoubledNumberEffect = <a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a>(() => {\n    console.log(this.num() * 2);\n  });\n  readonly logDoubledNumber = <a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a>&#x3C;number>((num) => {\n    console.log(num * 2);\n  });\n\n  constructor() {\n    this.logDoubledNumber(this.num);\n  }\n}\n</code-example>\n<p>However, <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> offers three distinctive advantages over <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code>:</p>\n<ul>\n<li><strong>Flexible Input</strong>: The input argument can be a static value, not just a signal. Additionally, the processor function can be called multiple times with different inputs.</li>\n<li><strong>No Injection Context Required</strong>: Unlike an <code><a href=\"api/effects/EffectNotification#effect\" class=\"code-anchor\">effect</a></code>, which requires an injection context or an Injector, <code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code>'s \"processor function\" can be called without an injection context.</li>\n<li><strong>Explicit Tracking</strong>: Only the Signal of the parameter is tracked, while Signals within the \"processor function\" stay untracked.</li>\n</ul>\n<h2 id=\"signalmethod-compared-to-rxmethod\"><code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> compared to <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/signals/signal-method#signalmethod-compared-to-rxmethod\"><i class=\"material-icons\">link</i></a></h2>\n<p><code><a href=\"api/signals/signalMethod\" class=\"code-anchor\">signalMethod</a></code> is <code><a href=\"api/signals/rxjs-interop/rxMethod\" class=\"code-anchor\">rxMethod</a></code> without RxJS, and is therefore much smaller in terms of bundle size.</p>\n<p>Be aware that RxJS is superior to Signals in managing race conditions. Signals have a glitch-free effect, meaning that for multiple synchronous changes, only the last change is propagated. Additionally, they lack powerful operators like <code>switchMap</code> or <code>concatMap</code>.</p>\n\n</div>\n\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - api/data/RequestData#method\n - api/effects/EffectNotification#effect\n - api/signals/rxjs-interop/rxMethod\n - api/signals/signalMethod\n - api/signals/type\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store-devtools/DevToolsFeatureOptions#import\n - api/store/on\n - api/store/testing/MockSelector#value\n - guide/signals/signal-method#advantages-over-effect\n - guide/signals/signal-method#automatic-cleanup\n - guide/signals/signal-method#initialization-outside-of-injection-context\n - guide/signals/signal-method#manual-cleanup\n - guide/signals/signal-method#signalmethod\n - guide/signals/signal-method#signalmethod-compared-to-rxmethod\n - https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/signals/signal-method.md?message=docs%3A%20describe%20your%20change...\n-->"
}