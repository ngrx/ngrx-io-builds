{
  "id": "guide/component/let",
  "title": "Let Directive",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/component/let.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"let-directive\">Let Directive<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#let-directive\"><i class=\"material-icons\">link</i></a></h1>\n<p>The <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive serves a convenient way of binding observables to a view context\n(DOM element's scope). It also helps with several internal processing under the hood.</p>\n<h2 id=\"usage\">Usage<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#usage\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive is provided through the <code><a href=\"api/component/LetModule\" class=\"code-anchor\">LetModule</a></code>.\nTo use it, add the <code><a href=\"api/component/LetModule\" class=\"code-anchor\">LetModule</a></code> to the <code>imports</code> of your standalone component or NgModule:</p>\n<code-example language=\"ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { Component } from '@angular/core';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/component/LetModule\" class=\"code-anchor\">LetModule</a> } from '@ngrx/component';\n\n@Component({\n  // ... other <a href=\"api/data/EntityDefinition#metadata\" class=\"code-anchor\">metadata</a>\n  standalone: true,\n  imports: [\n    // ... other imports\n    <a href=\"api/component/LetModule\" class=\"code-anchor\">LetModule</a>,\n  ],\n})\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class MyStandaloneComponent {}\n</code-example>\n<h2 id=\"comparison-with-ngif-and-async\">Comparison with <code>*ngIf</code> and <code>async</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#comparison-with-ngif-and-async\"><i class=\"material-icons\">link</i></a></h2>\n<p>The current way of binding an observable to the view looks like this:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *ngIf=\"number$ | async as n\">\n  &#x3C;app-number [number]=\"n\">&#x3C;/app-number>\n  \n  &#x3C;app-number-special [number]=\"n\">&#x3C;/app-number-special>\n&#x3C;/ng-container>\n</code-example>\n<p>The problem is that <code>*ngIf</code> is interfering with rendering.\nIn case of <code>0</code> (falsy value), the component would be hidden.</p>\n<p>The <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive takes over several things and makes it more convenient\nand safe to work with streams in the template:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"number$ as n\">\n  &#x3C;app-number [number]=\"n\">&#x3C;/app-number>\n&#x3C;/ng-container>\n\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"number$; let n\">\n  &#x3C;app-number [number]=\"n\">&#x3C;/app-number>\n&#x3C;/ng-container>\n</code-example>\n<h2 id=\"tracking-different-observable-events\">Tracking Different Observable Events<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#tracking-different-observable-events\"><i class=\"material-icons\">link</i></a></h2>\n<p>In addition to that it provides us information from the whole observable context.\nWe can track next, error, and complete events:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"number$ as n; let e = $error; let c = $complete\">\n  &#x3C;app-number [number]=\"n\" *ngIf=\"!e &#x26;&#x26; !c\">\n  &#x3C;/app-number>\n\n  &#x3C;p *ngIf=\"e\">There is an error: {{ e }}&#x3C;/p>\n  &#x3C;p *ngIf=\"c\">Observable is completed.&#x3C;/p>\n&#x3C;/ng-container>\n</code-example>\n<h2 id=\"combining-multiple-observables\">Combining Multiple Observables<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#combining-multiple-observables\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive can be also used with a dictionary of observables.\nThis feature provides the ability to create a view model object in the template:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"{ users: users$, query: query$ } as vm\">\n  &#x3C;app-search-bar [query]=\"vm.query\">&#x3C;/app-search-bar>\n  &#x3C;app-user-list [users]=\"vm.users\">&#x3C;/app-user-list>\n&#x3C;/ng-container>\n</code-example>\n<h2 id=\"using-suspense-template\">Using Suspense Template<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#using-suspense-template\"><i class=\"material-icons\">link</i></a></h2>\n<p>There is an option to pass the suspense template that will be displayed\nwhen an observable is in a suspense state:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"number$ as n; suspenseTpl: <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>\">\n  &#x3C;app-number [number]=\"n\">&#x3C;/app-number>\n&#x3C;/ng-container>\n\n&#x3C;ng-template #<a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>>\n  &#x3C;p>Loading...&#x3C;/p>\n&#x3C;/ng-template>\n</code-example>\n<div class=\"alert is-helpful\">\n<p>An observable is in a suspense state until it emits the first event (next, error, or complete).</p>\n</div>\n<p>In case a new observable is passed to the <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive at runtime,\nthe suspense template will be displayed again until the new observable emits the first event.</p>\n<h2 id=\"using-aliases-for-non-observable-values\">Using Aliases for Non-Observable Values<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#using-aliases-for-non-observable-values\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>*<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a></code> directive can also accept static (non-observable) values as input argument.\nThis feature provides the ability to create readable templates by using aliases for deeply nested properties:</p>\n<code-example language=\"html\">\n&#x3C;ng-container *<a href=\"api/component/LetDirective\" class=\"code-anchor\">ngrxLet</a>=\"userForm.controls.email as email\">\n  &#x3C;input type=\"text\" [formControl]=\"email\" />\n\n  &#x3C;ng-container *ngIf=\"email.errors &#x26;&#x26; (email.touched || email.dirty)\">\n    &#x3C;p *ngIf=\"email.errors.required\">This field is required.&#x3C;/p>\n    &#x3C;p *ngIf=\"email.errors.email\">This field must be an email.&#x3C;/p>\n  &#x3C;/ng-container>\n&#x3C;/ng-container>\n</code-example>\n<h2 id=\"included-features\">Included Features<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/component/let#included-features\"><i class=\"material-icons\">link</i></a></h2>\n<ul>\n<li>Binding is present even for falsy values.\n(See <a href=\"guide/component/let#comparison-with-ngif-and-async\">\"Comparison with <code>*ngIf</code> and <code>async</code>\"</a> section)</li>\n<li>Takes away the multiple usages of the <code>async</code> or <code><a href=\"api/component/PushPipe\" class=\"code-anchor\">ngrxPush</a></code> pipe.</li>\n<li>Allows displaying different content based on the current state of an observable.</li>\n<li>Allows combining multiple observables in the template.</li>\n<li>Provides a unified/structured way of handling <code>null</code> and <code>undefined</code>.</li>\n<li>Provides the ability to create readable templates by using aliases for nested properties.</li>\n<li>Triggers change detection using the <code><a href=\"api/component/RenderScheduler\" class=\"code-anchor\">RenderScheduler</a></code> that behaves differently in\nzone-full and zone-less mode.</li>\n<li>Distinct the same values in a row for better performance.</li>\n</ul>\n\n</div>\n\n<!-- links to this doc:\n - guide/component\n-->\n<!-- links from this doc:\n - api/component/LetDirective\n - api/component/LetModule\n - api/component/PushPipe\n - api/component/RenderScheduler\n - api/data/EntityCollection#loading\n - api/data/EntityDefinition#metadata\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store-devtools/DevToolsFeatureOptions#import\n - guide/component/let#combining-multiple-observables\n - guide/component/let#comparison-with-ngif-and-async\n - guide/component/let#included-features\n - guide/component/let#let-directive\n - guide/component/let#tracking-different-observable-events\n - guide/component/let#usage\n - guide/component/let#using-aliases-for-non-observable-values\n - guide/component/let#using-suspense-template\n - https://github.com/ngrx/platform/edit/master/projects/ngrx.io/content/guide/component/let.md?message=docs%3A%20describe%20your%20change...\n-->"
}