{
  "id": "guide/operators/operators",
  "title": "Operators",
  "contents": "\n\n\n  <div class=\"github-links\">\n    <a href=\"https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/operators/operators.md?message=docs%3A%20describe%20your%20change...\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n  </div>\n\n\n<div class=\"content\">\n<h1 id=\"operators\">Operators<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/operators/operators#operators\"><i class=\"material-icons\">link</i></a></h1>\n<p>The operators library provides some useful operators that are frequently\nused when managing state and side effects. </p>\n<h2 id=\"concatlatestfrom\"><code>concatLatestFrom</code><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/operators/operators#concatlatestfrom\"><i class=\"material-icons\">link</i></a></h2>\n<p>The <code>concatLatestFrom</code> operator functions similarly to <code>withLatestFrom</code> with one important difference - it lazily evaluates the provided Observable factory.</p>\n<p>This allows you to utilize the source value when selecting additional sources to concat.</p>\n<p>Additionally, because the factory is not executed until it is needed, it also mitigates the performance impact of creating some kinds of Observables.</p>\n<p>For example, when selecting data from the store with <code>store.select</code>, <code>concatLatestFrom</code> will prevent the\nselector from being evaluated until the source emits a value.</p>\n<p>The <code>concatLatestFrom</code> operator takes an Observable factory function that returns an array of Observables, or a single Observable.</p>\n<code-example header=\"router.effects.ts\">\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { Injectable } from '@angular/core';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { Title } from '@angular/platform-browser';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { map, tap } from 'rxjs/operators';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>, concatLatestFrom, <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>, <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a> } from '@ngrx/effects';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/store/Store\" class=\"code-anchor\">Store</a> } from '@ngrx/store';\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { <a href=\"api/router-store/routerNavigatedAction-1\" class=\"code-anchor\">routerNavigatedAction</a> } from '@ngrx/router-store';\n\n<a href=\"api/store-devtools/DevToolsFeatureOptions#import\" class=\"code-anchor\">import</a> { selectRouteData } from './router.selectors';\n\n@Injectable()\n<a href=\"api/store-devtools/DevToolsFeatureOptions#export\" class=\"code-anchor\">export</a> class RouterEffects {\n  updateTitle$ = <a href=\"api/effects/createEffect\" class=\"code-anchor\">createEffect</a>(() =>\n    this.actions$.pipe(\n      <a href=\"api/effects/ofType\" class=\"code-anchor\">ofType</a>(<a href=\"api/router-store/routerNavigatedAction-1\" class=\"code-anchor\">routerNavigatedAction</a>),\n      concatLatestFrom(() => this.store.select(selectRouteData)),\n      map(([, data]) => `Book Collection - ${data['<a href=\"api/router-store/MinimalActivatedRouteSnapshot#title\" class=\"code-anchor\">title</a>']}`),\n      tap((<a href=\"api/router-store/MinimalActivatedRouteSnapshot#title\" class=\"code-anchor\">title</a>) => this.titleService.setTitle(<a href=\"api/router-store/MinimalActivatedRouteSnapshot#title\" class=\"code-anchor\">title</a>))\n    ),\n    {\n      dispatch: false,\n    }\n  );\n\n  constructor(\n    private actions$: <a href=\"api/effects/Actions\" class=\"code-anchor\">Actions</a>,\n    private store: <a href=\"api/store/Store\" class=\"code-anchor\">Store</a>,\n    private titleService: Title\n  ) {}\n}\n</code-example>\n<h2 id=\"tapresponse\">tapResponse<a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/operators/operators#tapresponse\"><i class=\"material-icons\">link</i></a></h2>\n<p>An easy way to handle the response with an Observable in a safe way, without additional boilerplate is to use the <code><a href=\"api/operators/tapResponse\" class=\"code-anchor\">tapResponse</a></code> operator. It enforces that the error case is handled and that the effect would still be running should an error occur. It is essentially a simple wrapper around two operators:</p>\n<ul>\n<li><code>tap</code> that handles success and error cases.</li>\n<li><code>catchError(() => EMPTY)</code> that ensures that the effect continues to run after the error.</li>\n</ul>\n<code-example header=\"movies.store.ts\">\n  readonly getMovie = this.effect((movieId$: Observable&#x3C;string>) => {\n    return movieId$.pipe(\n      // ðŸ‘‡ Handle race condition with the proper choice of the flattening operator.\n      switchMap((<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>) => this.moviesService.fetchMovie(<a href=\"api/data/UpdateResponseData#id\" class=\"code-anchor\">id</a>).pipe(\n        //ðŸ‘‡ Act <a href=\"api/store/on\" class=\"code-anchor\">on</a> the result within inner pipe.\n        <a href=\"api/operators/tapResponse\" class=\"code-anchor\">tapResponse</a>(\n          (movie) => this.addMovie(movie),\n          (error: HttpErrorResponse) => this.logError(error),\n        ),\n      )),\n    );\n  });\n</code-example>\n<p>There is also another signature of the <code><a href=\"api/operators/tapResponse\" class=\"code-anchor\">tapResponse</a></code> operator that accepts the observer object as an input argument. In addition to the <code>next</code> and <code>error</code> callbacks, it provides the ability to pass <code>complete</code> and/or <code>finalize</code> callbacks:</p>\n<code-example header=\"movies.store.ts\">\n  readonly getMoviesByQuery = this.effect&#x3C;string>((query$) => {\n    return query$.pipe(\n      tap(() => this.patchState({ <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: true }),\n      switchMap((query) =>\n        this.moviesService.fetchMoviesByQuery(query).pipe(\n          <a href=\"api/operators/tapResponse\" class=\"code-anchor\">tapResponse</a>({\n            next: (movies) => this.patchState({ movies }),\n            error: (error: HttpErrorResponse) => this.logError(error),\n            finalize: () => this.patchState({ <a href=\"api/data/EntityCollection#loading\" class=\"code-anchor\">loading</a>: false }),\n          })\n        )\n      )\n    );\n  });\n</code-example>\n\n</div>\n\n<!-- links to this doc:\n - guide/signals/rxjs-integration\n-->\n<!-- links from this doc:\n - api/data/EntityCollection#loading\n - api/data/UpdateResponseData#id\n - api/effects/Actions\n - api/effects/createEffect\n - api/effects/ofType\n - api/operators/tapResponse\n - api/router-store/MinimalActivatedRouteSnapshot#title\n - api/router-store/routerNavigatedAction-1\n - api/store-devtools/DevToolsFeatureOptions#export\n - api/store-devtools/DevToolsFeatureOptions#import\n - api/store/Store\n - api/store/on\n - guide/operators/operators#concatlatestfrom\n - guide/operators/operators#operators\n - guide/operators/operators#tapresponse\n - https://github.com/ngrx/platform/edit/main/projects/ngrx.io/content/guide/operators/operators.md?message=docs%3A%20describe%20your%20change...\n-->"
}